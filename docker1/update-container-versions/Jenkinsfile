node ("built-in") {
    Map scmVars = checkout scm

    Map versions = loadEnvVars(readFile(file: "docker/.env"))

    boolean updateAvailable = false

    String latestMosquittoVersion
    dir ("mosquitto") {
        git (
            url: "https://github.com/eclipse/mosquitto.git",
            changelog: false,
            poll: false
        )

        latestMosquittoVersion = sh (
            script: "git describe --abbrev=0",
            returnStdout: true
        ) - "v"
    }

    String latestUnifiVersion
    dir ("unifi") {
        git (
            url: "https://github.com/jacobalberty/unifi-docker.git",
            changelog: false,
            poll: false
        )

        latestUnifiVersion = "v" + sortVersions(
            sh (
                script: "git tag --list",
                returnStdout: true
            ).tokenize("\n").findAll{it.startsWith("v") && !it.endsWith("-rc")}.collect{it - "v"}
        )[-1]
    }

    String latestNginxVersion
    dir ("nginx") {
        git (
            url: "https://github.com/nginx/nginx.git",
            changelog: false,
            poll: false
        )

        latestNginxVersion = sortVersions(
            sh (
                script: "git tag --list",
                returnStdout: true
            ).tokenize("\n").collect{it - "release-"}
        )[-1]
    }

    withCredentials([
        string(credentialsId: "HASS-TOKEN", variable: "token"),
        string(credentialsId: "DOCKER1-IP", variable: "docker1Ip")
    ]) {

        Map state = getHassEntityState("binary_sensor.updater", docker1Ip, token)
        if (state.state == "on") {
            updateAvailable = true
            versions.HASS_VERSION = state.attributes.newest_version.trim()
        }

        state = getHassEntityState("binary_sensor.certbot_updater", docker1Ip, token)
        if (state.state == "on") {
            updateAvailable = true
            versions.CERTBOT_VERSION = state.attributes.newest_version.trim()
        }

        state = getHassEntityState("sensor.docker_mosquitto", docker1Ip, token)
        if (state.attributes.image.split(":")[1] != latestMosquittoVersion) {
            updateAvailable = true
            versions.MOSQUITTO_VERSION = latestMosquittoVersion.trim()
        }

        state = getHassEntityState("sensor.docker_unifi", docker1Ip, token)
        if (state.attributes.image.split(":")[1] != latestUnifiVersion) {
            updateAvailable = true
            versions.UNIFI_VERSION = latestUnifiVersion.trim()
        }

        state = getHassEntityState("sensor.docker_nginx", docker1Ip, token)
        if (state.attributes.image.split(":")[1].split("-")[0] != latestNginxVersion) {
            updateAvailable = true
            versions.NGINX_VERSION = latestNginxVersion.trim()
        }
    }

    if (updateAvailable) {
        writeFile (
            file: "docker/.env",
            text: versions.collect{"${it.key}=${it.value}"}.join("\n")
        )
        sh "git config --global user.email jenkins@overlordserver.ddns.net"
        sh "git config --global user.name Jenkins"
        sh "git add docker/.env; git commit -m'Automated container version update'"

        sshagent(credentials: ["github-ssh"]) {
            sh "git push ${scmVars.GIT_URL} ${scmVars.GIT_BRANCH - "origin/"}"
        }
    }

    if (updateAvailable || params.forceUpdate) {
        build (
            job: "Docker1-Apply-Updates",
            wait: false
        )
    }

    cleanWs()
}

Map getHassEntityState(String entity, String docker1Ip, String token) {
    return readJSON (
        text: httpRequest (
            url: "http://${docker1Ip}:8123/api/states/${entity}",
            customHeaders: [[
                name: "Authorization",
                value: "Bearer " + token,
                maskValue: true
            ]]
        ).content
    )
}

@NonCPS
Map loadEnvVars(String text) {
    Map vars = [:]
    text.tokenize("\n").each {
        List split = it.tokenize("=")
        vars[split[0]] = split[1]
    }
    return vars
}